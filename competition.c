#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  piston,         sensorDigitalOut)
#pragma config(Sensor, dgtl12, override,       sensorDigitalIn)
#pragma config(Sensor, I2C_1,  ime_left,       sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ime_right,      sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  ime_lift,       sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           release,       tmotorVex269, openLoop)
#pragma config(Motor,  port2,           left1,         tmotorVex393HighSpeed, openLoop)
#pragma config(Motor,  port3,           left2,         tmotorVex393HighSpeed, openLoop, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port4,           right1,        tmotorVex393HighSpeed, openLoop)
#pragma config(Motor,  port5,           right2,        tmotorVex393HighSpeed, openLoop, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port6,           lift1,         tmotorVex393, openLoop, encoder, encoderPort, I2C_3, 1000)
#pragma config(Motor,  port7,           lift2,         tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port8,           lift3,         tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port9,           lift4,         tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
#include "driveAPI.h"
#include "auton.h"
#include "lcdAPI.h"
#include "diag.h"


////////////////////
// PRE-AUTONOMOUS //
////////////////////

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;
	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...

  short leftButton = 1;
	short centerButton = 2;
	short rightButton = 4;
  int choice1;
  int choice2;
  bLCDBacklight = true;

  /* Press and hold any LCD button BEFORE turning on robot
   * to enter autonomus selection mode.
   * If LCD buttons are not pressed (or LCD is not plugged in)
   * the default autonomous will run.
   */
  bool inMenu = nLCDButtons | SensorValue[override];
  if(inMenu)
  {
  	writeDebugStreamLine("GOING INTO MENU");
	}
  while(inMenu)
  {
  	lcdClear();
  	char* c = "\tChoice 1\nBLU\tDiag\tRED";
  	lcd_printf(c);
		int code = lcdWaitForBtnClick();
  	if (code==leftButton)
  	{
  		choice1=0b00;
  	}
  	if (code==rightButton)
  	{
  		choice1=0b01;
  	}
  	if (code==centerButton)
  	{
  		diag();
  		lcdClear();
  		c="\tChoice 1\nBLU\tDiag\tRED";
  		continue;
  	}

  	lcdClear();
		lcd_printf("\tChoice 2\nAuto\tBack\tPole");
		code = lcdWaitForBtnClick();
    // Display menu 2
  	if (code==leftButton)
  	{
  		choice2=0b00;
  	}
  	if (code==rightButton)
  	{
  		choice2=0b10;
  	}
  	if (code==centerButton)
  	{
  		continue;
  	}
		Program = choice1 + choice2;
		while(1)
		{
			lcdClear();
			switch (Program)
			{
				case BLU_AUTO:
					lcd_printf("\tBLU Auto\nDiag\tOK\tBack");
					break;
				case RED_AUTO:
					lcd_printf("\tRED Auto\nDiag\tOK\tBack");
					break;
				case BLU_POLE:
					lcd_printf("\tBLU Pole\nDiag\tOK\tBack");
					break;
				case RED_POLE:
					lcd_printf("\tRED Pole\nDiag\tOK\tBack");
					break;
			}
			code = lcdWaitForBtnClick();
			if(code==centerButton)
			{
				inMenu=false;
				break;
			}
			else if (code==leftButton)
				diag();
			else
				break;
		} // while(1)
	} // while(inMenu)
	//claw(false);
	lcdClear();
}

////////////////
// AUTONOMOUS //
////////////////

task autonomous()
{
  // .....................................................................................
  // Insert user code here.
  // .....................................................................................
	lcdClear();
	char* disp = (Program==0?"BLU Auto":Program==1?"RED Auto":Program==2?"BLU Pole":"RED Pole");
	displayLCDCenteredString(0, disp);

	switch(Program)
	{
		case BLU_AUTO:
			autonBluAuto();
			break;
		case RED_AUTO:
			autonRedAuto();
			break;
		case BLU_POLE:
			autonBluPole();
			break;
		case RED_POLE:
			autonRedPole();
			break;
	}

	AutonomousCodePlaceholderForTesting();  // Remove this function call once you have "real" code.
}

//////////////////
// USER CONTROL //
//////////////////

task usercontrol()
{
	// User control code here, inside the loop

	/*
	 * 7R: Low lift speed
	 * 7L: Claw release motor
	 * 8D: Toggle claw
	 * 8R: Jerk robot backwards
	 * 6U/D: Lift Control
	 */
	resetDriveIme();
	SensorValue[ime_lift] = 0;
	int btnDown = 5;
	int btnDown2 = 5;
	while(1)
	{
		setR(vexRT[Ch2]);
		setL(vexRT[Ch3]);

		if(vexRT[Btn6U] && !vexRT[Btn6D])
		{
			lift(LIFT_SPEED, true);
		}
		else if(vexRT[Btn6D] && !vexRT[Btn6U])
		{
			lift(LIFT_SPEED, false);
		}
		else
		{
			lift(14, true);
		}

		if(!vexRT[Btn8D] && btnDown<0)
		{
			btnDown = 5;
			SensorValue[piston] = !SensorValue[piston];
		}
		else if (vexRT[Btn8D])
		{
			btnDown--;
			wait1Msec(10);
		}

		if(!vexRT[Btn8R] && btnDown2<0)
		{
			btnDown2 = 5;
			driveMotors(-2,98,DRIVE_F);

		}
		else if (vexRT[Btn8R])
		{
			btnDown2--;
			wait1Msec(10);
		}

		if(vexRT[Btn7R])
		{
			LIFT_SPEED = LIFT_SPEED_LOW;
		}
		else
		{
			LIFT_SPEED = LIFT_SPEED_HIGH;
		}

		if(vexRT[Btn7L])
		{
			motor[release]=80;
		}
		else
		{
			motor[release]=0;
		}
	}

}
