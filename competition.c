#pragma config(Sensor, in1,    kGyroPort,    sensorGyro)
#pragma config(Sensor, dgtl1,  piston,         sensorDigitalOut)
#pragma config(Motor,  port6,           leftGear,      tmotorVex393, openLoop)
#pragma config(Motor,  port7,           rightGear,     tmotorVex393, openLoop)
#pragma config(Motor,  port8,           eleLeft,       tmotorVex393, openLoop)
#pragma config(Motor,  port9,           eleRight,      tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
#include "driveAPI.h"
#include "auton.h"
#include "lcdAPI.h"
#include "diag.h"


////////////////////
// PRE-AUTONOMOUS //
////////////////////

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;
  // All activities that occur before the competition starts
  // Example: clearing encoders, setting servo positions, ...

  short leftButton = 1;
  short centerButton = 2;
  short rightButton = 4;
  int choice1;
  int choice2;
  bLCDBacklight = true;

  /* Press and hold any LCD button BEFORE turning on robot
   * to enter autonomus selection mode.
   * If LCD buttons are not pressed (or LCD is not plugged in)
   * the default autonomous will run.
   */
  bool inMenu = nLCDButtons;
  while(inMenu)
  {
  	lcdClear();
  	char* c = "\tChoice 1\nBLU\tDiag\tRED";
  	lcd_printf(c);
		int code = lcdWaitForBtnClick();
  	if (code==leftButton)
  	{
  		choice1=0b00;
  	}
  	if (code==rightButton)
  	{
  		choice1=0b01;
  	}
  	if (code==centerButton)
  	{
  		diag();
  		lcdClear();
  		c="\tChoice 1\nBLU\tDiag\tRED";
  		continue;
  	}

  	lcdClear();
		lcd_printf("\tChoice 2\nAuto\tBack\tPole");
		code = lcdWaitForBtnClick();
    // Display menu 2
  	if (code==leftButton)
  	{
  		choice2=0b00;
  	}
  	if (code==rightButton)
  	{
  		choice2=0b10;
  	}
  	if (code==centerButton)
  	{
  		continue;
  	}
		Program = choice1 + choice2;
		while(1)
		{
			lcdClear();
			switch (Program)
			{
				case BLU_AUTO:
					lcd_printf("\tBLU Auto\nDiag\tOK\tBack");
					break;
				case RED_AUTO:
					lcd_printf("\tRED Auto\nDiag\tOK\tBack");
					break;
				case BLU_POLE:
					lcd_printf("\tBLU Pole\nDiag\tOK\tBack");
					break;
				case RED_POLE:
					lcd_printf("\tRED Pole\nDiag\tOK\tBack");
					break;
			}
			code = lcdWaitForBtnClick();
			if(code==centerButton)
			{
				inMenu=false;
				break;
			}
			else if (code==leftButton)
				diag();
			else
				break;
		} // while(1)
	} // while(inMenu)
	//claw(false);
	lcdClear();
	calibrateGyro();
}

////////////////
// AUTONOMOUS //
////////////////

task autonomous()
{
  // .....................................................................................
  // Insert user code here.
  // .....................................................................................
	lcdClear();
	char* disp = (Program==0?"BLU Auto":Program==1?"RED Auto":Program==2?"BLU Pole":"RED Pole");
	displayLCDCenteredString(0, disp);

	switch(Program)
	{
		case BLU_AUTO:
			autonBluAuto();
			break;
		case RED_AUTO:
			autonRedAuto();
			break;
		case BLU_POLE:
			autonBluPole();
			break;
		case RED_POLE:
			autonRedPole();
			break;
	}

	AutonomousCodePlaceholderForTesting();  // Remove this function call once you have "real" code.
}

//////////////////
// USER CONTROL //
//////////////////

task usercontrol()
{
  calibrateGyro();
  word x,y,r;
  int btnDown = 5;
  while(true) {
    // ==== collect joystick & sensor values ====
    x = vexRT[kChTranslate]* (isSlowActive ? multiplierSlow : 1); // x component
    y = vexRT[kChYaw]* (isSlowActive ? multiplierSlow : 1); // y component
    r = vexRT[kChFrwrd]* (isSlowActive ? multiplierSlow : 1); //Rotation componenet

    setXDrive(x, y, r);

    //Main Lift
    if(vexRT[Btn6U] && !vexRT[Btn6D])
    {
    	motor[eleLeft] = 96 * (isSlowActive ? multiplierSlow : 1);
    	motor[eleRight] = 96 * (isSlowActive ? multiplierSlow : 1);
    }
    else if(!vexRT[Btn6U] && vexRT[Btn6D])
    {
    	motor[eleLeft] = -96 *(isSlowActive ? multiplierSlow : 1);
    	motor[eleRight] = -96 *(isSlowActive ? multiplierSlow : 1);
    }
    else
    {
    	motor[eleLeft] = 15;
    	motor[eleRight] = 15;
    }

    //Arm Lift
    if(vexRT[Btn5D] && !vexRT[Btn5U])
    {
    	motor[rightGear] = 96*(isSlowActive ? multiplierSlow : 1);
    	motor[leftGear] = 96*(isSlowActive ? multiplierSlow : 1);
    }
    else if(!vexRT[Btn5D] && vexRT[Btn5U])
    {
    	motor[rightGear] = -96 *(isSlowActive ? multiplierSlow : 1);
    	motor[leftGear] = -96 *(isSlowActive ? multiplierSlow : 1);
    }
    else
    {
    	//Default Pressure
    	motor[rightGear] = -15;
    	motor[leftGear] = -15;
    }

    //Slow mode
    if (vexRT[Btn8L] && debounceSlow == 0) {
    	debounceSlow = 5;
    	isSlowActive = !isSlowActive;
    }
    else if (debounceSlow > 0) {
  			debounceSlow--;
  	}


    //Piston Claw
    if(!vexRT[Btn8D] && btnDown==0)
    {
    	btnDown=5;
    	SensorValue[piston]=!SensorValue[piston];
    }
    else if(vexRT[Btn8D] && btnDown>0)
    {
    	btnDown--;
    }

    wait1Msec(kDelay);
  }

}
