#pragma config(Sensor, in1,    kGyroPort,      sensorGyro)
#pragma config(Sensor, dgtl9,  piston,         sensorDigitalOut)
#pragma config(Sensor, dgtl1,  LED1,           sensorLEDtoVCC)
#pragma config(Motor,  port6,           leftGear,      tmotorVex393, openLoop)
#pragma config(Motor,  port7,           rightGear,     tmotorVex393, openLoop)
#pragma config(Motor,  port8,           eleLeft,       tmotorVex393, openLoop)
#pragma config(Motor,  port9,           eleRight,      tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

bool isAutonomousModeRunning = false;

const bool doUseGyro = false; // enable gyroscopic sensor
bool isGyroCalibrated = false;

//DPI
bool isSlowActive = false; //Is slow mode active
float multiplierSlow = 0.3;
byte debounceSlow = 0; //Debouncer for it (If 0 can switch)

//XDrive Settings
const TVexJoysticks kChTranslate = Ch1; // Translation Control
const TVexJoysticks kChYaw = Ch4; //Rotating control
const TVexJoysticks kChFrwrd = Ch2; //Forward Movement
const short kDelay = 25; // milliseconds for loop delay
const ubyte kNumWheels = 4; // number of drive wheels
const ubyte kNumMotorsPerWheel = 2; // max number of motors per wheel
const tMotor kNone = -1; // used for indicating the lack of an additional motor
const tMotor kMotorPort[kNumWheels][kNumMotorsPerWheel] = { // drive motor ports/names
    {port2, kNone}, // front-left
    {port3, kNone}, // front-right
    {port4, kNone}, // back-left
    {port5, kNone}  // back-right
};

void calibrateGyro()
{
	if (doUseGyro && !isGyroCalibrated) {
    writeDebugStreamLine("Gyro Calibrated");
    isGyroCalibrated = true;

    // completely clear out any previous sensor readings by setting the port to "sensorNone"
    SensorType[kGyroPort] = sensorNone;
    wait1Msec(1000);
    SensorType[kGyroPort] = sensorGyro; // reconfigure as sensorGyro
    wait1Msec(2000); // wait for calibration: ROBOT MUST STAY STILL

    SensorScale[kGyroPort] = 138; // adjust SensorScale to correct the scaling for your gyro
    SensorFullCount[kGyroPort] = 3599; // fix rollover to be "...3598, 3599, 0, 1..."
	}
}

void setXDrive(word yaw, word forward, word strafe) {
	//yaw = Left Joystick 4
	//forward = Right Joystick 1
	//strafe = Right Joystick 2
  float radius,theta,wheelSpeed[kNumWheels],topSpeed;
    radius = sqrt(pow(yaw,2) + pow(strafe,2)); // forward = sqrt(sideways^2 + rotate^2)
    theta = atan2(strafe,yaw)*180.0/PI; // t = arctan(rotate/sideways) [converted from radians to degrees]

    float x,y;
    x = radius * cosDegrees(theta);
    y = radius * sinDegrees(theta);

    // ==== set speeds, including rotation ====
    wheelSpeed[0] = x + y + forward; // front-left
    wheelSpeed[1] = x - y - forward; // front-right
    wheelSpeed[2] = x - y + forward; // back-left
    wheelSpeed[3] = x + y - forward; // back-right


    // ==== normalize speeds ====
    topSpeed = 0.0;
    for(ubyte i=0; i<kNumWheels; i++)
      if(abs(wheelSpeed[i]) > topSpeed)
        topSpeed = abs(wheelSpeed[i]); // find highest desired speed
    if(topSpeed > 127.0)
      for(ubyte i=0; i<kNumWheels; i++)
        wheelSpeed[i] /= topSpeed/127.0; // downscale all speeds so none are above 127

    // ==== update motor powers ====
    for(ubyte i=0; i<kNumWheels; i++) // cycle through all wheels
      for(ubyte j=0; j<kNumMotorsPerWheel; j++) // cycle through all motors for each wheel
        if(kMotorPort[i][j] != kNone) // check existence of motor
          motor[kMotorPort[i][j]] = (word)wheelSpeed[i]; // update motor power
}


task userDriveHolo() {
  word x,y,r;
	int btnDown = 2;
  while(true) {
  	if (isAutonomousModeRunning) {
  		continue;
  	}
  	if (vexRT[Btn7U]) {
  		isAutonomousModeRunning = true;
  		StartTask(autonomous);
  	}

    // ==== collect joystick & sensor values ====
    x = vexRT[kChYaw]* (isSlowActive ? multiplierSlow : 1); // x component
    y = vexRT[kChFrwrd]* (isSlowActive ? multiplierSlow : 1); // y component
    r = -vexRT[kChTranslate]* (isSlowActive ? multiplierSlow : 1); //Rotation componenet

    setXDrive(x, y, r);

    //Main Lift
    if(vexRT[Btn6U] && !vexRT[Btn6D])
    {
    	motor[eleLeft] = 96 * (isSlowActive ? multiplierSlow : 1);
    	motor[eleRight] = 96 * (isSlowActive ? multiplierSlow : 1);
    }
    else if(!vexRT[Btn6U] && vexRT[Btn6D])
    {
    	motor[eleLeft] = -96 *(isSlowActive ? multiplierSlow : 1);
    	motor[eleRight] = -96 *(isSlowActive ? multiplierSlow : 1);
    }
    else
    {
    	motor[eleLeft] = 15;
    	motor[eleRight] = 15;
    }

    //Arm Lift
    if(vexRT[Btn5D] && !vexRT[Btn5U])
    {
    	motor[rightGear] = 96*(isSlowActive ? multiplierSlow : 1);
    	motor[leftGear] = 96*(isSlowActive ? multiplierSlow : 1);
    }
    else if(!vexRT[Btn5D] && vexRT[Btn5U])
    {
    	motor[rightGear] = -96 *(isSlowActive ? multiplierSlow *2 : 1);
    	motor[leftGear] = -96 *(isSlowActive ? multiplierSlow *2 : 1);
    }
    else
    {
    	//Default Pressure
    	motor[rightGear] = -15;
    	motor[leftGear] = -15;
    }

    //Slow mode
    if (!vexRT[Btn8L] && debounceSlow == 0) {
    	debounceSlow = 2;
    	isSlowActive = !isSlowActive;
    }
    else if (vexRT[Btn8L] && debounceSlow > 0) {
  			debounceSlow--;
  	}
  	SensorValue[LED1] = isSlowActive;

    //Piston Claw
    if(!vexRT[Btn8D] && btnDown==0)
    {
    	btnDown=2;
    	SensorValue[piston]=!SensorValue[piston];
    }
    else if(vexRT[Btn8D] && btnDown>0)
    {
    	btnDown--;
    }

    wait1Msec(kDelay);
  }
}


void pre_auton()
{
  calibrateGyro();
  bStopTasksBetweenModes = true;
}

task autonomous()
{
	motor[leftGear] = -15;
	motor[rightGear] = -15;
    	motor[eleRight] = 96;
    	motor[eleLeft] = 96;
    	wait10Msec(100);
    	motor[eleRight] = 15;
    	motor[eleLeft] = 15;
    	wait10Msec(10);
    	//P1 = Rotate
	//P2 = Forward Motion
  //P3 = Sideways Motion
   setXDrive(0, 127, 127);
   wait10Msec(70);
   setXDrive(0, -127, 0);
   wait10Msec(50);
   setXDrive(0, 127, 0);
   wait10Msec(25);
   setXDrive(0, -127, 0);
   wait10Msec(25);
   setXDrive(127,-5,0);
   wait10Msec(30);
   setXDrive(0,0,0);
   isAutonomousModeRunning = false;
}



task usercontrol()
{
  calibrateGyro();
  StartTask(userDriveHolo);

  while(true)
    wait1Msec(100);
}
